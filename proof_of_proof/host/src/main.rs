// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use axum::{extract::Json, http::StatusCode, response::IntoResponse, routing::post, Router};
use methods::{PROOF_OF_PROOF_GUEST_ELF, PROOF_OF_PROOF_GUEST_ID};
use proof_core::GuestInput;
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use tokio::net::TcpListener;
#[tokio::main]
async fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let app = Router::new().route("/get_proof", post(get_proof_handler));

    let listener = TcpListener::bind("0.0.0.0:3000").await.unwrap();
    tracing::info!("listening on {}", listener.local_addr().unwrap());
    axum::serve(listener, app).await.unwrap();
}

async fn get_proof_handler(Json(body): Json<GuestInput>) -> impl IntoResponse {
    match prove(body) {
        Ok(_) => (StatusCode::OK, "Proof generated successfully".to_string()),
        Err(e) => {
            tracing::error!("Error generating proof: {}", e);
            (StatusCode::INTERNAL_SERVER_ERROR, e.to_string())
        }
    }
}

fn prove(guest_input: GuestInput) -> Result<Receipt, Box<dyn std::error::Error>> {
    let env = ExecutorEnv::builder().write(&guest_input)?.build()?;

    let prover = default_prover();

    let prove_info = prover.prove(env, PROOF_OF_PROOF_GUEST_ELF)?;

    let receipt = prove_info.receipt;

    receipt.verify(PROOF_OF_PROOF_GUEST_ID)?;

    Ok(receipt)
}
